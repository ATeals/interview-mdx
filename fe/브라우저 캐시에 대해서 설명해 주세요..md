---
title: 브라우저 캐시에 대해서 설명해 주세요.
tags: 
keyword:
  - 브라우저
slug:
---
---

> [https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work#cssom_구축building_the_cssom](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work#cssom_%EA%B5%AC%EC%B6%95building_the_cssom)

> [https://yozm.wishket.com/magazine/detail/1338/](https://yozm.wishket.com/magazine/detail/1338/)

## TL;DR

<aside> 💡

브라우저의 렌더링 과정을 각각 한줄로 요약하자면 다음과 같다.

1. **탐색**: URL 입력이나 클릭으로 웹 페이지 탐색 시작.
2. **DNS 조회**: 도메인 이름을 IP 주소로 변환.
3. **TCP 핸드셰이크**: 안정적인 연결을 위해 TCP 세션 설정.
4. **TLS 협상**: 암호화와 서버 인증으로 보안 연결 수립.
5. **HTTP 요청/응답**: 서버로부터 웹 페이지 데이터 가져옴.
6. **구문 분석**: HTML과 CSS를 트리 구조로 변환.
7. **프리로드 스캐너**: 외부 리소스를 미리 요청.
8. **DOM/CSSOM 트리 구축**: 문서 구조와 스타일을 트리로 변환.
9. **렌더 트리 생성**: 보이는 요소만 포함한 트리 생성.
10. **레이아웃**: 화면 요소의 크기와 위치 계산.
11. **페인트**: 화면에 픽셀로 요소 렌더링.
12. **합성**: 레이어를 합쳐 최종 화면 표시.
13. **상호작용**: 사용자 입력에 응답할 준비 완료. </aside>

## 개요

웹 성능에 있어서 두 가지 주요한 문제는 지연시간과 싱글스레드이다.

빠른 로딩을 위해서 신경써야하는 것은 빠르게 요청하는 것이다. 네트워크 지연시간은 네트워크를 통해 컴퓨터로 바이트를 전송하는데 걸리는 시간을 의미한다. 웹 최적화는 페이지 로드가 최대한 빠르게 이뤄지도록 하는 것이다.

대부분 브라우저는 싱글스레드다. 메인스레드가 요청된 모든 작업을 수행하면서 유저의 상호작용에 반응할 수 있도록 보장하려면, 렌더링 시간이 가장 중요하다.

## 탐색(Navigation)

> _탐색(Navigation)_ 은 웹페이지를 로딩하는 첫 단계입니다. 사용자가 주소창에 URL을 입력하거나, 링크를 클릭하고, 폼(form)을 제출하는 등의 동작을 통해 요청을 보낼 때마다 발생합니다.

### DNS 조회 (DNS Lookup)

웹 페이지를 탐색하기 위해서는 자원의 위치를 알아야 한다. 만약 [`https://example.com`](https://example.com/) 를 탐색한다면, HTML 페이지는 IP 주소가 `93.184.216.34` 인 서버에 위치하고 있다. 이 사이트를 한 번도 방문한 적이 없다면 DNS 조회가 필요하다.

최초 요청 이후 IP는 일정 기간동안 캐시 된다. 이름 서버에 다시 연락하는 대신 캐시를 사용해 후속 요청 속도를 높인다.

DNS 조회는 보통 호스트 이름 하나당 한번만 수행한다. 하지만 DNS 조회는 요청된 페이지에서 참조하는 다른 호스트 이름에 대해서는 각각 수행해야 한다. 글꼴, 이미지, 스크립트, 광고 그리고 다른 자원들이 서로 다른 호스트 이름을 가지고 있다면, DNS 조회는 각각에 대해서 모두 수행되어야 한다. (이는 모바일 네트워크 환경에서는 성능에 문제가 될 수 있다.)

### TCP 핸드셰이크(TCP Handshake)

IP주소를 안 이후에는 브라우저는 서버와 TCP 3방향 핸드셰이크를 통해 연결을 설정한다. 이 방식은 데이터 전송 전, 통신하려는 두 주체가 TCP 소켓 연결을 위한 매개변수를 주고 받을 수 있도록 만들어져있다.

### TLS 협상 (TLS Negotiation)

HTTPS를 이용한 보안성 있는 연결을 위해서는 또 다른 “핸드셰이크”가 필요하다. 이 핸드셰이크는 통신 암호화에 쓰일 암호를 결정하고, 서버를 확인하고, 실제 데이터 전송 전에 안전한 연결이 이루어지도록 한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/51749967-aaf9-4e14-9817-f82f567ba784/ac7d14d2-06bf-4c29-b643-abfbdf9b8f50/image.png)

8번의 왕복 후에, 브라우저는 마침내 요청을 실행할 수 있다.

## 응답 (Response)

웹서버로 연결이 성립된 뒤, 브라우저는 유저 대신 초기 HTTP GET Request를 보낸다. 이때 대부분 HTML 파일을 요청한다.

```html
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>My simple page</title>
    <link rel="stylesheet" src="styles.css" />
    <script src="myscript.js"></script>
  </head>
  <body>
    <h1 class="heading">My Page</h1>
    <p>A paragraph with a <a href="<https://example.com/about>">link</a></p>
    <div>
      <img src="myimage.jpg" alt="image description" />
    </div>
    <script src="anotherscript.js"></script>
  </body>
</html>

```

이 초기 요청에 대한 응답은 수신된 첫 바이트 데이터를 포함한다. Time to First Byte(TTFB)는 사용자가 요청을 보내고 HTML의 첫 패킷을 받는데 걸린 시간이다. 첫번째 컨텐츠 청크는 일반적으로 14kb 크기의 데이터다.

### 혼잡 제어(congestion control) / TCP Slow Start

전송되는 세그먼트 수의 균형을 맞추기 위해 [TCP 슬로우 스타트](https://developer.mozilla.org/ko/docs/Glossary/TCP_slow_start) 알고리즘을 사용하여 최대 네트워크 대역폭이 결정될 때까지 전송되는 데이터의 양을 점차적으로 늘리고 네트워크 부하가 높은 경우 전송되는 데이터의 양을 줄인다.

## 구문 분석 (Parsing)

브라우저가 첫 번째 데이터의 청크를 받으면, 수신된 정보를 구문 분석하기 시작한다. 구문 분석은 브라우저가 네트워크를 통해 받은 데이터를 DOM이나 CSSOM으로 바꾸는 단계다. 이는 렌더러가 화면에 페이지를 그리는데 사용된다.

요청된 HTML 페이지의 크기가 초기 패킷의 크기인 14kb 보다 크더라도, 브라우저는 구문 분석을 시작하고 가지고 있는 데이터 수준에서 렌더링을 시도한다. 이것이 웹 성능 최적화에서 브라우저가 페이지를 렌더링 하는데 필요한 모든 것, 아니면 적어도 페이지 템플릿(첫 렌더링에 필요한 HTML, CSS)만이라도 첫 14kb에 포함해야하는 이유다.

## DOM 트리 구축 (Building the DOM tree)

> [중요한 렌더링 경로](https://developer.mozilla.org/ko/docs/Web/Performance/Critical_rendering_path)를 다섯 가지 단계로 설명한다.

첫 단계는 HTML을 처리해 DOM 트리를 만드는 것이다. 이 단계는 토큰화와 트리 생성을 포함한다. HTML 토큰은 시작 및 종료 태그, 속성 이름 및 값을 포함한다. 문서가 잘 구성되어 있다면 구문 분석은 명확하고 빠르다. 구문분석기는 토큰화된 입력을 분석해 트리를 만든다.

DOM 노드 개수가 많아질수록, DOM 트리를 만드는데 더 오랜 시간이 걸린다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/51749967-aaf9-4e14-9817-f82f567ba784/88652fe1-dc31-47c5-bf1d-dc7236dae70b/image.png)

구문 분석기가 이미지같은 논블로킹 자원을 발견하면, 브라우저는 해당 자원을 요청하고 분석을 계속 진행한다. 구문 분석은 CSS 파일을 만났을 때도 지속될 수 있다.

하지만 async나 defer 같은 설정이 되어있지 않은 `script` 태그는 렌더링을 막고, 구문 분석을 중지시킨다. 브라우저의 프리로드 스캐너가 이 작업을 가속화 하지만, 과도한 스크립트는 여전히 주요 병목 구간이다.

### 프리로드 스캐너(Preload scanner)

브라우저가 DOM 트리를 만드는 것은 메인쓰레드를 차지한다. 따라서, 프리로드 스캐너는 사용 가능한 컨텐츠를 분석하고 CSS나 JS, 웹 폰트 같은 우선순위가 높은 자원을 요청한다.

프리로드 스캐너 덕분에 구문 분석기가 외부 자원에 대한 참조 요청을 기다리지 않아도 된다. 프리로드 스캐너가 자원을 뒤에서 미리 요청한다. 그래서 구문 분석기가 요청되는 자원에 다다를 때 쯤이면, 이미 그 자원들을 전송받고 있거나 받은 상태일 것이다.

### CSSOM 구축(Building the CSSOM)

두 번째 단계는 CSS를 처리하고 CSSOM 트리를 만드는 것이다. CSS 객체 모델은 DOM과 비슷하다. 이 두 모델은 트리구조이다. 둘은 각각 독립적인 자료구조다. 브라우저는 CSS 규칙을 이해할 수 있고 작업할 수 있도록 스타일 맵으로 변환한다. 브라우저는 CSS에 있는 각 규칙을 읽고, 트리노드를 만든다. CSS 선택기에 기반해서 부모, 자식 형제 관계의 노드를 만든다.

CSSOM 트리는 사용자 에이전트의 스타일 시트를 포함한다. 브라우저는 노드에 적용 가능한 가장 일반적인 규칙부터 적용한다. 그리고 재귀적으로 더 구체적으로 적용된 규칙에 따라 계산된 스타일을 수정한다. 즉, 속성 값을 캐스케이드한다.

CSSOM을 만드는 것은 매우매우 빠르고 개발자 도구에서 고유한 색으로 표시되지 않는다. 개발자 도구에서 “스타일 재계산”에는 CSS 구문분석, 트리생성, 재귀적인 스타일계산에 필요한 총 시간을 표시한다. 이는 한번의 DNS 조회보다 짧기 때문에 웹 성능 최적화 관점에서 CSSOM은 성능 향상에 큰 기여를 할 수 있는 영역은 아니다.

### JavaScript 컴파일 (JavaScript Compilation)

css가 분석되고 CSSOM이 생성되는 동안, 프리 스캐너 덕분에 JS파일 같은 다른 자원도 다운로드 된다. JS는 해석, 컴파일, 구문분석 및 실행된다. 스크립트는 추상 구문 트리로 구문분석 된다. 일부 브라우저 엔진은 추상구문트리를 인터프리터에게 넘긴다. 그결과 메인스레드에서 실행되는 바이트코드가 생성된다. 이것이 JS 컴파일 과정이다.

### 접근성 트리 구축(Building the Accessibility Tree)

브라우저는 접근성 트리를 만든다. 보조 장치는 이 트리를 이용해 내용을 분석하고 해석한다. 접근성 객체 모델(AOM)은 DOM의 의미 버전이다. DOM 업데이트 시 접근성 트리도 업데이트 한다.

AOM이 만들어지기 전까지, 화면 리더기는 컨텐츠에 접근할 수 없다.

## 렌더(Render)

렌더링 과정에는 스타일, 레이아웃, 페인트 그리고 합성이 포함된다.

CSSOM과 DOM트리는 구문 분석 과정에서 생성되고 **렌더트리**로 합성된다. 렌더트리는 보이는 요소의 **레이아웃을 계산**한다. 이후 화면에 요소가 **페인트**된다. 어떤 경우 컨텐츠가 자신만의 **레이어**를 가지도록 조작되고, 나중에 **합성**된다. 화면의 일부분을 CPU 대신 GPU가 그리면서 메인스레드의 부담을 줄이고 성능을 향상시킨다.

### 스타일(Style)

세번째 단계는 DOM과 CSSOM을 합쳐 렌더 트리를 만드는 것이다. 이는 DOM 트리의 루트부터 시작해 눈에 보이는 노드를 순회하여 만들어진다.

### 레이아웃(Layout)

네번째 단계는 렌더 트리를 기반으로 각 노드의 도형 값을 계산하기 위해 레이아웃을 실행하는 것이다. 레이아웃은 렌더 트리에 있는 모든 노드의 너비, 높이, 위치를 결정한다. 또한 페이지에서 각 객체의 크기와 위치를 계산한다.

**리플로우**는 레이아웃 이후에 있는 페이지의 일부분이나 전체 문서에 대한 크기나 위피에 대한 결정이다.

렌더트리가 한 번 만들어진 뒤, 레이아웃이 시작된다. 렌더트리는 (보이지 않아도) 계산된 스타일과 함께 어떤 노드가 화면에 표시될지 식별한다. 하지만 각 노드의 위치나, 좌표를 알지는 못한다. 각 객체의 정확한 크기와 위치를 결정하기 위해, 브라우저는 렌더 트리의 루트부터 시작해 순회한다.

레이아웃 단계에서는 뷰포트의 크기를 고려한다. 뷰포트의 크기를 기본으로 하여, 레이아웃은 일반적으로 body에서 시작해 모든 후손의 크기를 각 요소의 박스 모델 속성을 통해 계산한다. 이미지와 같이 크기를 모르는 요소를 위해서 위치 표시 공간을 남긴다.

처음 노드의 사이즈와 위치가 결정되는 것을 **레이아웃**이라고 부른다. 이후 노드의 크기와 위치를 다시 계산하는 것은 **리플로우**라고 부른다. 만일 첫 레이아웃이 크기의 선언이 없는 이미지가 오기 전에 일어난다면, 이미지 크기를 알게 된 이후 리플로우가 한 번 발생한다.

### 페인트(Paint)

마지막 단계는 각 노드를 페인팅하는 것이다. 페인팅 혹은 레지스터화 단계에서, 브라우저는 레이아웃 단계에서 계산된 각 박스를 실제 화면의 픽셀로 변환한다.

페인팅에서 텍스트, 색, 경계, 그림자, 버튼, 이미지 같은 대체 요소를 포함해 모든 요소의 시각적인 부분을 화면에 그리는 작업이 포함된다. 브라우저는 이를 매우 빠르게 해야한다.

부드러운 스크롤이나 애니메이션을 위해 스타일 계산, 리플로우, 페인팅과 같이 메인스레드를 점유하는 모든 작업은 브라우저를 16.67ms 미만만 차지해야 한다.

첫 페인팅 보다 다시 페인팅하는 것이 더 빠르게 마무리되기 위해, 화면에 그리는 작업은 일반적으로 몇 개의 레이어로 구분된다. 이것이 일어나면 합성이 필요하다.

페인팅은 레이아웃 트리의 요소를 레이어로 분리할 수 있다. 컨텐츠를 CPU 메인스레드에서 GPU 레이어로 격상하는 것은 페인트 및 리페인트의 성능을 높인다. 레이어를 가동시키는 구체적인 속성과 요소가 있다. 요소에는 `video`, `canvas` 가 있고 속성에는 `opacity` , 3D `transform` , `will-change` 등이 있다. 자손 노드가 위의 이유중 하나로 자신만의 레이어를 필요로 하는 것이 아니면, 이 노드는 그들의 레이어에서 그들의 자손과 함께 그려진다.

레이어는 성능을 향상 시킨다. 하지만 메모리 관리 측면에서 봤을 때는 비싼 작업이다. 따라서 웹 성능 최적화 전략으로 남용하지 말아야 한다.

### 합성(Compositing)

문서의 각 섹션이 다른 레이어에서 그려질 때, 섹션을 겹쳐놓으면서 그것들이 올바른 순서로 화면에 그려지는 것과 정확한 렌더링을 보장하기 위해 합성이 필요하다.

페이지가 계속 자원을 로드하면, 리플로우가 발생할 수 있다. 리플로우는 리페인트와 재합성을 일으킬 수 있다. 이미지 사이즈를 미리 정해놨다면 리플로우는 필요하지 않다. 그리고 리페인트 외야할 레이어만 다시 리페인트 하고 필요하다면 합성이 이뤄난다.

## 상호작용(Interactivity)

메인스레드가 페이지를 그리는 것을 완료하면, 모든 것이 준비되었다고 생각할 수 있다. 하지만 꼭 그렇지는 않다. 만약 지연된 JS를 다운했다면, onload 이벤트가 발생할때, 코드가 실행된다면, 메인스레드는 여전이 바쁠 것이다.

**TTI**(Time to Interactive)는 DNS 조회와 SSL 연결이 이루어지는 첫 요청부터 페이지가 상호작용할 준비가 될 때까지 얼마나 걸리는지를 측정하는 단위다.

**FMP (**첫번째 콘텐츠가 포함된 페인트, First Meaningful Paint) 이후 페이지가 사용자와의 상호작용에 50ms 이대로 응답할 때를 상호작용 가능 시점으로 판단한다. 만일 메인스레드가 구문분석, 컴파일, JS 실행에 사용되고 있다면, 메인 스레드를 사용할 수 없고 따라서 사용자 상호작용에 50ms 이내로 적절하게 반응하지 못한다.